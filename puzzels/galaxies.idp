/* IDP file generated by Python script...
 *
 * Galaxies (logic puzzle)
 * 
 * Rules:
 * 
 * 1) Every region should have two-way rotational symmetry,
 * 2) should contain exactly one dot which is in its centre, and
 * 3) should contain no lines separating two of its own squares from each other.
 * 4) No black holes.
 * 
 * Copyright (c) Dries007 & Laurens VDW 2019
 * 
 * Play field:
 *             1
 *   01234567890
 *  0┏━┯━┯━┯━┯━┓
 *  1┃ ┆ A ┆ ┆ ┃
 *  2┠┄┼┄┼┄┼┄┼┄┨
 *  3┃ ┆B┆ ┆ ┆ ┃
 *  4┠┄┼┄┼┄┼┄C┄┨
 *  5┃ ┆D┆ ┆ ┆ ┃
 *  6┠┄┼┄┼┄┼┄┼┄┨
 *  7┃ ┆ ┆ ┆ ┆ ┃
 *  8┠E┼┄┼F┼┄┼G┨
 *  9┃ ┆H┆ ┆ ┆ ┃
 * 10┗━┷━┷━┷━┷━┛
 */
// Vocabulary Block
vocabulary V {
    type X isa nat
    type Y isa nat
    Center(X, Y)
    Walls(X, Y)
    Square(X, Y)
    BelongsTo(X, Y, X, Y)
    Size: nat
}
// Structure Block
structure S : V {
    X = {0..10}
    Y = {0..10}
    Size = 10
    Center = { (4, 1); (3, 3); (8, 4); (3, 5); (1, 8); (5, 8); (9, 8); (3, 9) }
}
// Theory Block
theory T : V {
    // Define a list of all "squares". (odd coordinates)
    { !x, y: Square(x, y) <- x%2=1 & y%2=1. }
    
    // Basic wall definitions
    // ----------------------
    // Walls cannot be in Square spots.
    !(x, y) in Walls: ~Square(x, y).
    // Walls cannot pass trough a center.
    !(x, y) in Walls: ~Center(x, y).
    // Every edge is a wall.
    !x: Walls(x, 0) & Walls(x, Size).
    !y: Walls(0, y) & Walls(Size, y).
    // A wall cannot be a dead end. It would subdivided a region. This translates too:
    // Every wall must have 2 or more neighbours.   X are equal, Y are +-1    OR Y are equal, X are +- 1.
    !(x1, y1) in Walls: #{x2, y2: Walls(x2, y2) & ((x1=x2 & (y1=y2-1|y1=y2+1)) | (y1=y2 & (x1=x2-1|x1=x2+1)))} >= 2.
    
    // Basic Square -> Center definitions
    // ----------------------------------
    // If its not a square, it cant belong to anything.
    !x1, y1: ~Square(x1, y1) => #{x2, y2: BelongsTo(x1, y1, x2, y2)} = 0.
    // No polygamy here.
    !(x1, y1) in Square: #{x2, y2: BelongsTo(x1, y1, x2, y2)} = 1.
    // The belong-to part must be a center.
    !(x1, y1) in Square: ?(x2, y2) in Center: BelongsTo(x1, y1, x2, y2).
    // Center ownership    
    // Case 1: Center is on a cross
    !(x, y) in Center: (x%2=0 & y%2=0) => BelongsTo(x-1, y-1, x, y) & BelongsTo(x-1, y+1, x, y) & BelongsTo(x+1, y+1, x, y) & BelongsTo(x+1, y-1, x, y).
    // Case 2: Center is on a wall in X
    !(x, y) in Center: (x%2=0 & y%2=1) => BelongsTo(x+1, y, x, y) & BelongsTo(x-1, y, x, y).
    // Case 3: Center is on a wall in Y
    !(x, y) in Center: (x%2=1 & y%2=0) => BelongsTo(x, y+1, x, y) & BelongsTo(x, y-1, x, y).
    // Case 4: Center is in a square
    !(x, y) in Center: Square(x, y) => BelongsTo(x, y, x, y).
    
    // More advanced definitions
    // -------------------------
    // Check if walls surround regions (and only between regions)
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1-2, y1, cx1, cy1) <=> Walls(x1-1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1+2, y1, cx1, cy1) <=> Walls(x1+1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1-2, cx1, cy1) <=> Walls(x1, y1-1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1+2, cx1, cy1) <=> Walls(x1, y1+1)).
    // Check region symmetry: mirror is 2 times center minus coordinate
    !(x, y) in Square: !(cx, cy) in Center: BelongsTo(x, y, cx, cy) <=> BelongsTo(2*cx-x, 2*cy-y, cx, cy).
    
    
    // todo: Check region continuity
    // !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => ().
    
    
}
// Default main
procedure main() {
    stdoptions.nbmodels = 5
    printmodels(modelexpand(T,S))
}

/* IDP Output
-=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=-
(Reading from stdin)
Warning: Verifying and/or autocompleting structure S
Warning: Consistency cannot be checked for functions over an infinite domain.
Warning: Derived sort X for variable x2. At 
Warning: Derived sort Y for variable y2. At 
Number of models: 1
Model 1
=======
structure  : V {
  X = { 0..10 }
  Y = { 0..10 }
  BelongsTo = { 1,1,4,1; 1,3,3,3; 1,5,3,5; 1,7,1,8; 1,9,1,8; 3,1,4,1; 3,3,3,3; 3,5,3,5; 3,7,5,8; 3,9,3,9; 5,1,4,1; 5,3,3,3; 5,5,3,5; 5,7,5,8; 5,9,5,8; 7,1,4,1; 7,3,8,4; 7,5,8,4; 7,7,8,4; 7,9,5,8; 9,1,8,4; 9,3,8,4; 9,5,8,4; 9,7,9,8; 9,9,9,8 }
  Center = { 1,8; 3,3; 3,5; 3,9; 4,1; 5,8; 8,4; 9,8 }
  Square = { 1,1; 1,3; 1,5; 1,7; 1,9; 3,1; 3,3; 3,5; 3,7; 3,9; 5,1; 5,3; 5,5; 5,7; 5,9; 7,1; 7,3; 7,5; 7,7; 7,9; 9,1; 9,3; 9,5; 9,7; 9,9 }
  Walls = { 0,0; 0,1; 0,2; 0,3; 0,4; 0,5; 0,6; 0,7; 0,8; 0,9; 0,10; 1,0; 1,2; 1,4; 1,6; 1,10; 2,0; 2,2; 2,4; 2,6; 2,7; 2,8; 2,9; 2,10; 3,0; 3,2; 3,4; 3,6; 3,8; 3,10; 4,0; 4,2; 4,4; 4,6; 4,8; 4,9; 4,10; 5,0; 5,2; 5,4; 5,6; 5,10; 6,0; 6,2; 6,3; 6,4; 6,5; 6,6; 6,7; 6,8; 6,10; 7,0; 7,2; 7,8; 7,10; 8,0; 8,1; 8,2; 8,6; 8,7; 8,8; 8,9; 8,10; 9,0; 9,6; 9,10; 10,0; 10,1; 10,2; 10,3; 10,4; 10,5; 10,6; 10,7; 10,8; 10,9; 10,10 }
  Size = 10
}


-=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=-
Solution:
Inner Walls: {(6, 6), (5, 6), (2, 8), (4, 8), (8, 9), (6, 2), (1, 6), (7, 2), (1, 2), (4, 9), (6, 7), (2, 9), (8, 1), (4, 4), (6, 3), (3, 6), (2, 2), (3, 4), (8, 6), (6, 4), (5, 4), (3, 2), (2, 6), (8, 2), (1, 4), (8, 7), (4, 2), (9, 6), (6, 5), (2, 7), (7, 8), (4, 6), (6, 8), (3, 8), (8, 8), (5, 2), (2, 4)}
Mapping Center -> Square:
{(1, 8): {(1, 9), (1, 7)},
 (3, 3): {(1, 3), (3, 3), (5, 3)},
 (3, 5): {(1, 5), (5, 5), (3, 5)},
 (3, 9): {(3, 9)},
 (4, 1): {(5, 1), (3, 1), (1, 1), (7, 1)},
 (5, 8): {(5, 9), (5, 7), (3, 7), (7, 9)},
 (8, 4): {(7, 3), (9, 1), (9, 3), (7, 7), (7, 5), (9, 5)},
 (9, 8): {(9, 9), (9, 7)}}
Grid:
            1
  01234567890
 0┏━┯━┯━┯━┳━┓
 1┃a┆aAa┆a┃c┃
 2┣━┿━┿━╈━╃┄┨
 3┃b┆B┆b┃c┆c┃
 4┣━┿━┿━╉┄C┄┨
 5┃d┆D┆d┃c┆c┃
 6┣━╈━┿━╉┄╆━┫
 7┃e┃f┆f┃c┃g┃
 8┠E╊━╅F╄━╉G┨
 9┃e┃H┃f┆f┃g┃
10┗━┻━┻━┷━┻━┛

Valid: True
*/
