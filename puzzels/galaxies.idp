/* IDP file generated by Python script...
 *
 * Galaxies (logic puzzle)
 * 
 * Rules:
 * 
 * 1) Every region should have two-way rotational symmetry,
 * 2) should contain exactly one dot which is in its centre, and
 * 3) should contain no lines separating two of its own squares from each other.
 * 4) No black holes.
 * 
 * Copyright (c) Dries007 & Laurens VDW 2019
 * 
 * Play field:
 *             1
 *   01234567890
 *  0┏━┯━┯━┯━┯━┓
 *  1┃ ┆ A ┆ ┆ ┃
 *  2┠┄┼┄┼┄┼┄┼┄┨
 *  3┃ ┆B┆ ┆ ┆ ┃
 *  4┠┄┼┄┼┄┼┄C┄┨
 *  5┃ ┆D┆ ┆ ┆ ┃
 *  6┠┄┼┄┼┄┼┄┼┄┨
 *  7┃ ┆ ┆ ┆ ┆ ┃
 *  8┠E┼┄┼F┼┄┼G┨
 *  9┃ ┆H┆ ┆ ┆ ┃
 * 10┗━┷━┷━┷━┷━┛
 */
// Vocabulary Block
vocabulary V {
    type X isa nat
    type Y isa nat
    Center(X, Y)
    Walls(X, Y)
    Square(X, Y)
    BelongsTo(X, Y, X, Y)
    Reachable(X, Y, X, Y)
    Size: nat
}
// Structure Block
structure S : V {
    X = {0..10}
    Y = {0..10}
    Size = 10
    Center = { (4, 1); (3, 3); (8, 4); (3, 5); (1, 8); (5, 8); (9, 8); (3, 9) }
}
// Theory Block
theory T : V {
    // Define a list of all "squares". (odd coordinates)
    { !x, y: Square(x, y) <- x%2=1 & y%2=1. }
    
    // Basic wall definitions
    // ----------------------
    // Walls cannot be in Square spots.
    !(x, y) in Walls: ~Square(x, y).
    // Walls cannot pass trough a center.
    !(x, y) in Walls: ~Center(x, y).
    // Every edge is a wall.
    !x: Walls(x, 0) & Walls(x, Size).
    !y: Walls(0, y) & Walls(Size, y).
    // A wall cannot be a dead end. It would subdivided a region. This translates too:
    // Every wall must have 2 or more neighbours.   X are equal, Y are +-1    OR Y are equal, X are +- 1.
    !(x1, y1) in Walls: #{x2, y2: Walls(x2, y2) & ((x1=x2 & (y1=y2-1|y1=y2+1)) | (y1=y2 & (x1=x2-1|x1=x2+1)))} >= 2.
    
    // Basic Square -> Center definitions
    // ----------------------------------
    // If its not a square, it cant belong to anything.
    !x1, y1: ~Square(x1, y1) => #{x2, y2: BelongsTo(x1, y1, x2, y2)} = 0.
    // No polygamy here.
    !(x1, y1) in Square: #{x2, y2: BelongsTo(x1, y1, x2, y2)} = 1.
    // The belong-to part must be a center.
    !(x1, y1) in Square: ?(x2, y2) in Center: BelongsTo(x1, y1, x2, y2).
    // Center ownership    
    // Case 1: Center is on a cross
    !(x, y) in Center: (x%2=0 & y%2=0) => BelongsTo(x-1, y-1, x, y) & BelongsTo(x-1, y+1, x, y) & BelongsTo(x+1, y+1, x, y) & BelongsTo(x+1, y-1, x, y).
    // Case 2: Center is on a wall in X
    !(x, y) in Center: (x%2=0 & y%2=1) => BelongsTo(x+1, y, x, y) & BelongsTo(x-1, y, x, y).
    // Case 3: Center is on a wall in Y
    !(x, y) in Center: (x%2=1 & y%2=0) => BelongsTo(x, y+1, x, y) & BelongsTo(x, y-1, x, y).
    // Case 4: Center is in a square
    !(x, y) in Center: Square(x, y) => BelongsTo(x, y, x, y).
    
    // More advanced definitions
    // -------------------------
    // Check if walls surround regions (and only between regions)
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1-2, y1, cx1, cy1) <=> Walls(x1-1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1+2, y1, cx1, cy1) <=> Walls(x1+1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1-2, cx1, cy1) <=> Walls(x1, y1-1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1+2, cx1, cy1) <=> Walls(x1, y1+1)).
    
    // Check region symmetry: mirror is 2 times center minus coordinate
    !(x, y) in Square: !(cx, cy) in Center: BelongsTo(x, y, cx, cy) <=> BelongsTo(2*cx-x, 2*cy-y, cx, cy).
        
    // todo: Check region continuity
    // !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => ().
    // Reachable if it is next to a center on a wall
	{!x, y, cx, cy: Reachable(x, y, cx, cy) <- Center(cx, cy)&(((x-cx = 0)&((y-cy = 1)|(y-cy = -1)))|((y-cy = 0)&((x-cx = 1)|(x-cx = -1))))&(BelongsTo(x, y, cx, cy)).
    // Reachable if it's next to a center in a square
     !x, y, cx, cy: Reachable(x, y, cx, cy) <- Center(cx, cy)&(((x-cx = 0)&((y-cy = 2)|(y-cy = -2)))|((y-cy = 0)&((x-cx = 2)|(x-cx = -2))))&(BelongsTo(x, y, cx, cy)).
    // Reachable if it's next to a center on a cross
     !x, y, cx, cy: Reachable(x, y, cx, cy) <- Center(cx, cy)&(((x-cx = 1)|(x-cx = -1))&((y-cy = 1)|(y-cy = -1))).
    // Reachable if square next to it can reache the center
     !x1, y1, cx, cy: Reachable(x1, y1, cx, cy) <- ?x2, y2: Reachable(x2, y2, cx, cy)&(((x1-x2 = 0)&((y1-y2 = 2)|(y1-y2 = -2)))|((y1-y2 = 0)&((x1-x2 = 2)|(x1-x2 = -2))))&BelongsTo(x1, y1, cx, cy).
    }
    
    // square has to be reachable to center for it to belong to the center
    !x, y, cx, cy: BelongsTo(x, y, cx, cy) => Reachable(x, y, cx, cy).
    
    
}
// Default main
procedure main() {
    stdoptions.nbmodels = 5
    printmodels(modelexpand(T,S))
}

/* IDP Output
-=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=-
(Reading from stdin)
Warning: Verifying and/or autocompleting structure S
Warning: Consistency cannot be checked for functions over an infinite domain.
Warning: Derived sort X for variable x2. At 
Warning: Derived sort Y for variable y2. At 
Unsatisfiable
Number of models: 0

-=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=--=#=-
*/
