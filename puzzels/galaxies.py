#!/bin/env python3

"""
Galaxies (logic puzzle)

Rules:

1) Every region should have two-way rotational symmetry,
2) should contain exactly one dot which is in its centre, and
3) should contain no lines separating two of its own squares from each other.
4) No black holes.

Copyright (c) Dries007 & Laurens VDW 2019
"""
import itertools
import re
import string
import subprocess as sp
import textwrap
from pprint import pprint


TEMPLATE = string.Template('''/* IDP file generated by Python script...
 *
${header}
 * 
 * Play field:
${field}
 */
// Vocabulary Block
vocabulary V {
    type X isa nat
    type Y isa nat
    Center(X, Y)
    Walls(X, Y)
    Square(X, Y)
    BelongsTo(X, Y, X, Y)
    Reachable(X, Y, X, Y)
    Size: nat
}
// Structure Block
structure S : V {
    X = {0..${size}}
    Y = {0..${size}}
    Size = ${size}
    Center = { ${centers} }
}
// Theory Block
theory T : V {
    // Define a list of all "squares". (odd coordinates)
    { !x, y: Square(x, y) <- x%2=1 & y%2=1. }
    
    // Basic wall definitions
    // ----------------------
    // Walls cannot be in Square spots.
    !(x, y) in Walls: ~Square(x, y).
    // Walls cannot pass trough a center.
    !(x, y) in Walls: ~Center(x, y).
    // Every edge is a wall.
    !x: Walls(x, 0) & Walls(x, Size).
    !y: Walls(0, y) & Walls(Size, y).
    // A wall cannot be a dead end. It would subdivided a region. This translates too:
    // Every wall must have 2 or more neighbours.   X are equal, Y are +-1    OR Y are equal, X are +- 1.
    !(x1, y1) in Walls: #{x2, y2: Walls(x2, y2) & ((x1=x2 & (y1=y2-1|y1=y2+1)) | (y1=y2 & (x1=x2-1|x1=x2+1)))} >= 2.
    
    // Basic Square -> Center definitions
    // ----------------------------------
    // If its not a square, it cant belong to anything.
    !x1, y1: ~Square(x1, y1) => #{x2, y2: BelongsTo(x1, y1, x2, y2)} = 0.
    // No polygamy here.
    !(x1, y1) in Square: #{x2, y2: BelongsTo(x1, y1, x2, y2)} = 1.
    // The belong-to part must be a center.
    !(x1, y1) in Square: ?(x2, y2) in Center: BelongsTo(x1, y1, x2, y2).
    // Center ownership    
    // Case 1: Center is on a cross
    !(x, y) in Center: (x%2=0 & y%2=0) => BelongsTo(x-1, y-1, x, y) & BelongsTo(x-1, y+1, x, y) & BelongsTo(x+1, y+1, x, y) & BelongsTo(x+1, y-1, x, y).
    // Case 2: Center is on a wall in X
    !(x, y) in Center: (x%2=0 & y%2=1) => BelongsTo(x+1, y, x, y) & BelongsTo(x-1, y, x, y).
    // Case 3: Center is on a wall in Y
    !(x, y) in Center: (x%2=1 & y%2=0) => BelongsTo(x, y+1, x, y) & BelongsTo(x, y-1, x, y).
    // Case 4: Center is in a square
    !(x, y) in Center: Square(x, y) => BelongsTo(x, y, x, y).
    
    // More advanced definitions
    // -------------------------
    // Check if walls surround regions (and only between regions)
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1-2, y1, cx1, cy1) <=> Walls(x1-1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1+2, y1, cx1, cy1) <=> Walls(x1+1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1-2, cx1, cy1) <=> Walls(x1, y1-1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1+2, cx1, cy1) <=> Walls(x1, y1+1)).
    
    // Check region symmetry: mirror is 2 times center minus coordinate
    !(x, y) in Square: !(cx, cy) in Center: BelongsTo(x, y, cx, cy) <=> BelongsTo(2*cx-x, 2*cy-y, cx, cy).
        
    // todo: Check region continuity
    // !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => ().
    // Reachable if it is next to a center on a wall
	{!x, y, cx, cy: Reachable(x, y, cx, cy) <- Center(cx, cy)&(((x-cx = 0)&((y-cy = 1)|(y-cy = -1)))|((y-cy = 0)&((x-cx = 1)|(x-cx = -1))))&(BelongsTo(x, y, cx, cy)).
    // Reachable if it's next to a center in a square
     !x, y, cx, cy: Reachable(x, y, cx, cy) <- Center(cx, cy)&(((x-cx = 0)&((y-cy = 2)|(y-cy = -2)))|((y-cy = 0)&((x-cx = 2)|(x-cx = -2))))&(BelongsTo(x, y, cx, cy)).
    // Reachable if it's next to a center on a cross
     !x, y, cx, cy: Reachable(x, y, cx, cy) <- Center(cx, cy)&(((x-cx = 1)|(x-cx = -1))&((y-cy = 1)|(y-cy = -1))).
    // Reachable if square next to it can reache the center
     !x1, y1, cx, cy: Reachable(x1, y1, cx, cy) <- ?x2, y2: Reachable(x2, y2, cx, cy)&(((x1-x2 = 0)&((y1-y2 = 2)|(y1-y2 = -2)))|((y1-y2 = 0)&((x1-x2 = 2)|(x1-x2 = -2))))&BelongsTo(x1, y1, cx, cy).
    }
    
    // square has to be reachable to center for it to belong to the center
    !x, y, cx, cy: BelongsTo(x, y, cx, cy) => Reachable(x, y, cx, cy).
    
    
}
// Default main
procedure main() {
    stdoptions.nbmodels = ${nbmodels}
    printmodels(modelexpand(T,S))
}
''')

'''
Model 1
=======
structure  : V {
  X = { 0..14 }
  Y = { 0..14 }
  BelongsTo = { 1,1,3,2; 1,3,3,2; 1,5,2,5; 1,7,2,8; 1,9,2,8; 1,11,6,9; 1,13,2,13; 3,1,3,2; 3,3,3,2; 3,5,2,5; 3,7,2,8; 3,9,2,8; 3,11,6,9; 3,13,2,13; 5,1,3,2; 5,3,3,2; 5,5,6,9; 5,7,6,9; 5,9,6,9; 5,11,6,9; 5,13,6,9; 7,1,8,1; 7,3,9,4; 7,5,6,9; 7,7,6,9; 7,9,6,9; 7,11,6,9; 7,13,6,9; 9,1,8,1; 9,3,9,4; 9,5,9,4; 9,7,6,9; 9,9,10,10; 9,11,10,10; 9,13,10,13; 11,1,12,2; 11,3,12,2; 11,5,9,4; 11,7,6,9; 11,9,10,10; 11,11,10,10; 11,13,10,13; 13,1,12,2; 13,3,12,2; 13,5,13,9; 13,7,13,9; 13,9,13,9; 13,11,13,9; 13,13,13,9 }
  Center = { 2,5; 2,8; 2,13; 3,2; 6,9; 8,1; 9,4; 10,10; 10,13; 12,2; 13,9 }
  Square = { 1,1; 1,3; 1,5; 1,7; 1,9; 1,11; 1,13; 3,1; 3,3; 3,5; 3,7; 3,9; 3,11; 3,13; 5,1; 5,3; 5,5; 5,7; 5,9; 5,11; 5,13; 7,1; 7,3; 7,5; 7,7; 7,9; 7,11; 7,13; 9,1; 9,3; 9,5; 9,7; 9,9; 9,11; 9,13; 11,1; 11,3; 11,5; 11,7; 11,9; 11,11; 11,13; 13,1; 13,3; 13,5; 13,7; 13,9; 13,11; 13,13 }
  Walls = { 0,0; 0,1; 0,2; 0,3; 0,4; 0,5; 0,6; 0,7; 0,8; 0,9; 0,10; 0,11; 0,12; 0,13; 0,14; 1,0; 1,4; 1,6; 1,10; 1,12; 1,14; 2,0; 2,4; 2,6; 2,10; 2,12; 2,14; 3,0; 3,4; 3,6; 3,10; 3,12; 3,14; 4,0; 4,4; 4,5; 4,6; 4,7; 4,8; 4,9; 4,10; 4,12; 4,13; 4,14; 5,0; 5,4; 5,14; 6,0; 6,1; 6,2; 6,3; 6,4; 6,14; 7,0; 7,2; 7,4; 7,14; 8,0; 8,2; 8,4; 8,5; 8,6; 8,8; 8,9; 8,10; 8,11; 8,12; 8,13; 8,14; 9,0; 9,2; 9,6; 9,8; 9,12; 9,14; 10,0; 10,1; 10,2; 10,3; 10,4; 10,6; 10,8; 10,12; 10,14; 11,0; 11,4; 11,6; 11,8; 11,12; 11,14; 12,0; 12,4; 12,5; 12,6; 12,7; 12,8; 12,9; 12,10; 12,11; 12,12; 12,13; 12,14; 13,0; 13,4; 13,14; 14,0; 14,1; 14,2; 14,3; 14,4; 14,5; 14,6; 14,7; 14,8; 14,9; 14,10; 14,11; 14,12; 14,13; 14,14 }
  Size = 14
}
'''

def up(x, y, offset=1):
    return x, y-offset


def down(x, y, offset=1):
    return x, y+offset


def left(x, y, offset=1):
    return x-offset, y


def right(x, y, offset=1):
    return x+offset, y


DIRECTIONS = (up, down, left, right)


def is_square(x, y):
    return x % 2 == 1 and y % 2 == 1


def get_center_char(x):
    return string.ascii_uppercase[x]


def all_touching_squares(x, y):
    if x % 2 == 0 and y % 2 == 0:
        return {left(*up(x, y)), left(*down(x, y)), right(*up(x, y)), right(*down(x, y))}
    if x % 2 == 0:
        return {left(x, y), right(x, y)}
    if y % 2 == 0:
        return {up(x, y), down(x, y)}
    return {(x, y)}


def get_neighbours(x, y, size):
    if not is_square(x, y):
        raise ValueError('Not Square')
    neighbours = set()
    if x != 1:
        neighbours.add(left(x, y, offset=2))
    if x != size-2:
        neighbours.add(right(x, y, offset=2))
    if y != 1:
        neighbours.add(up(x, y, offset=2))
    if y != size-2:
        neighbours.add(down(x, y, offset=2))
    # print('get_neighbours', (x, y), size, neighbours)
    return neighbours


def between(a, b):
    ax, ay = a
    bx, by = b
    assert (ax+bx)//2 == (ax+bx)/2, (ay+by)//2 == (ay+by)/2
    return (ax+bx)//2, (ay+by)//2


def is_continuous(squares, size):
    # print('is_continuous', squares, size)
    if len(squares) == 0:
        return True
    explored = set()
    to_explore = {next(iter(squares))}
    while len(to_explore) > 0:
        pos = to_explore.pop()
        explored.add(pos)
        for n in get_neighbours(*pos, size):
            if n not in explored and n in squares:
                to_explore.add(n)
    # print('explored', explored)
    # print(len(set(squares) ^ explored) == 0)
    return len(set(squares) ^ explored) == 0


def mirror(square, center):
    # print('mirror', square, center)
    sx, sy = square
    cx, cy = center
    dx, dy = cx - sx, cy - sy
    return cx + dx, cy + dy


class Galaxies:
    def __init__(self, size):
        self.centers = {}
        self.squares = set()
        self.mapping_s2c = {}
        self.mapping_c2s = {}
        self.size = 2 * size + 1
        
        self.nb_models = 5
        edges = {0, self.size-1}
        self.edge_walls = {(x, y) for x, y in itertools.product(range(self.size), range(self.size)) if x in edges or y in edges}
        self.walls = set(self.edge_walls)

    def __repr__(self):
        return self.get_grid()

    def get_grid(self):
        return '  ' + ''.join(str(x // 10) if x >= 10 else ' ' for x in range(self.size)) + '\n' + \
               '  ' + ''.join(str(x % 10) for x in range(self.size)) + '\n' + \
               '\n'.join('%2d' % y + ''.join(self.get_inner_tile(x, y) for x in range(self.size)) for y in range(self.size))

    def set_center(self, x, y):
        self.centers[x, y] = get_center_char(len(self.centers))

    def check_valid(self):
        """
        Must return True if the puzzle is solved correctly.
        todo: Finish.
        """
        # Helper objects
        all_coords = tuple(itertools.product(range(self.size), range(self.size)))
        squares = set((x, y) for x, y in all_coords if is_square(x, y))
        non_squares = set((x, y) for x, y in all_coords if not is_square(x, y))

        # Conditions
        # Implemented in IDP already.
        all_walls_connected = all(sum(f(x, y) in self.walls for f in DIRECTIONS) >= 2 for x, y in self.walls)
        no_walls_in_boxes = not any(x % 2 and y % 2 for x, y in self.walls)
        every_square_has_value = all((x, y) in self.mapping_s2c for x, y in squares)
        only_squares_have_values = not any((x, y) in self.mapping_s2c for x, y in non_squares)
        # Polygamy (more than 1 value per square) is impossible because it's a dict.
        only_mappings_to_centers = len(set(self.mapping_c2s.keys()) - set(self.centers.keys())) == 0
        center_touching_squares = all(len(all_touching_squares(x, y) - self.mapping_c2s[x, y]) == 0 for x, y in self.centers.keys())
        different_walls = all((between(n, c) in self.walls for n in get_neighbours(*c, self.size) if self.mapping_c2s[n] != self.mapping_c2s[c]) for c in squares)
        same_no_walls = all((between(n, c) not in self.walls for n in get_neighbours(*c, self.size) if self.mapping_c2s[n] == self.mapping_c2s[c]) for c in squares)

        # Not yet implemented in IDP.
        continuous = all(is_continuous(region, self.size) for c, region in self.mapping_c2s.items())
        symmetric = all(mirror(s, c) in squares and self.mapping_s2c[mirror(s, c)] == c for s, c in self.mapping_s2c.items())

        # Assert anything to make sure there is no unnoticed regression.
        assert all_walls_connected
        assert no_walls_in_boxes
        assert every_square_has_value
        assert only_squares_have_values
        assert only_mappings_to_centers
        assert center_touching_squares
        assert different_walls
        assert same_no_walls
        # assert continuous
        # assert symmetric

        print('continuous:', continuous)
        print('symmetric:', symmetric)

        return continuous and symmetric

    def get_inner_tile(self, x, y):
        """
        Unicode Box Drawing Character Madness
        """
        pos = (x, y)
        if pos in self.centers:
            # return '╳'  # '◯'
            return self.centers[pos]

        wall = pos in self.walls
        wall_up = up(x, y) in self.walls
        wall_down = down(x, y) in self.walls
        wall_left = left(x, y) in self.walls
        wall_right = right(x, y) in self.walls

        x_even = x % 2 == 0
        y_even = y % 2 == 0

        end = self.size - 1
        edges = {0, end}

        # Special cas for edges, so that the printed version looks better.
        # Literally the corer and edge cases...
        if wall and x in edges or y in edges:
            if y == 0:
                if x == 0:
                    return '┏'
                if x == end:
                    return '┓'
                if not x_even:
                    return '━'
                return '┳' if wall_down else '┯'
            if y == end:
                if x == 0:
                    return '┗'
                if x == end:
                    return '┛'
                if not x_even:
                    return '━'
                return '┻' if wall_up else '┷'
            if x == 0:
                if not y_even:
                    return '┃'
                return '┣' if wall_right else '┠'
            if x == end:
                if not y_even:
                    return '┃'
                return '┫' if wall_left else '┨'

        if x_even and y_even:
            # Crossing
            if not wall:
                return '┼'

            # 4 legs are walls
            if all((wall_up, wall_down, wall_left, wall_right)):
                return '╋'

            # 1 leg is a wall. Should not happen.
            if wall_up and not any((wall_down, wall_left, wall_right)):
                return '╀'
            if wall_down and not any((wall_up, wall_left, wall_right)):
                return '╁'
            if wall_left and not any((wall_up, wall_down, wall_right)):
                return '┽'
            if wall_right and not any((wall_up, wall_down, wall_left)):
                return '┾'

            # 3 legs are walls.
            if not wall_up and all((wall_down, wall_left, wall_right)):
                return '╈'
            if not wall_down and all((wall_up, wall_left, wall_right)):
                return '╇'
            if not wall_left and all((wall_up, wall_down, wall_right)):
                return '╊'
            if not wall_right and all((wall_up, wall_down, wall_left)):
                return '╉'

            # 2 legs are a wall.
            if all((wall_up, wall_down)) and not any((wall_left, wall_right)):
                return '╂'
            if all((wall_left, wall_right)) and not any((wall_up, wall_down)):
                return '┿'
            if all((wall_up, wall_left)) and not any((wall_down, wall_right)):
                return '╃'
            if all((wall_up, wall_right)) and not any((wall_down, wall_left)):
                return '╄'
            if all((wall_down, wall_left)) and not any((wall_up, wall_right)):
                return '╅'
            if all((wall_down, wall_right)) and not any((wall_up, wall_left)):
                return '╆'

            # return '┼' if not wall else '╋'
            # return 'x' if not wall else 'X'
            raise ValueError('impossible')

        if y_even:
            return '┄' if not wall else '━'
        if x_even:
            return '┆' if not wall else '┃'

        if pos not in self.mapping_s2c:
            return ' '
        center = self.mapping_s2c[pos]
        return self.centers[center].lower()

    def to_idp(self):
        return TEMPLATE.substitute(
            header=textwrap.indent(__doc__.strip(), ' * ', lambda x: True),
            field=textwrap.indent(self.get_grid(), ' * ', lambda x: True),
            size=self.size - 1,
            centers='; '.join(repr(x) for x in self.centers),
            nbmodels=self.nb_models,
        )

    def run(self, interactive=False):
        idp = self.to_idp()
        # print('IDP Input')
        # print(10*'~')
        # print(idp)
        # print('Running IDP...')

        p = sp.Popen(('/home/laurens/idp/idp3-3.7.1-Linux/usr/local/bin/idp', ), universal_newlines=True, stdin=sp.PIPE, stdout=sp.PIPE,  stderr=sp.STDOUT)
        stdout, stderr = p.communicate(idp)

        # print('IDP Returned: ', run.returncode)
        # print(10*'~')
        # print(run.stdout)
        # print('Solutions:')

        with open('galaxies.idp', 'w') as f:
            print(idp, file=f)
            print('/* IDP Output', file=f)
            print(20 * '-=#=-', file=f)
            print(stdout, file=f)
            print(20*'-=#=-', file=f)
            for line in stdout.splitlines():
                self.parse_input(line, file=f)
            print('*/', file=f)

        if interactive:
            while True:
                self.parse_input(input('IDP Output > '))

    def parse_input(self, inp, file=None):
        if len(inp.strip()) == 0:
            print('Solution:', file=file)
            # print('Centers:', self.centers, file=file)
            print('Inner Walls:', self.walls - self.edge_walls, file=file)
            print('Mapping Center -> Square:', file=file)
            pprint(self.mapping_c2s, stream=file, width=160)
            # print('Mapping Square -> Center:', file=file)
            # pprint(self.mapping_s2c, stream=file, width=160)
            print('Grid:', file=file)
            print(self, file=file)
            print(file=file)
            if file:
                print(self)
                print('Valid:', self.check_valid())
            print('Valid:', self.check_valid(), file=file)
            return

        match = re.match(r'^\s*Walls = {(.*)}$', inp)
        if match:
            self.walls = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            return
        match = re.match(r'^\s*Center = {(.*)}$', inp)
        if match:
            centers = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            assert len(set(self.centers.keys()) ^ centers) == 0
            return
        match = re.match(r'^\s*Square = {(.*)}$', inp)
        if match:
            self.squares = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            return
        match = re.match(r'^\s*Size = (\d+)$', inp)
        if match:
            assert int(match.group(1)) == self.size-1
            return
        match = re.match(r'^\s*BelongsTo = {(.*)}$', inp)
        if match:
            mapping = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            self.mapping_s2c = {(sx, sy): (cx, cy) for sx, sy, cx, cy in mapping}
            self.mapping_c2s = {(cx, cy): set() for cx, cy in self.mapping_s2c.values()}
            for sx, sy, cx, cy in mapping:
                self.mapping_c2s[cx, cy].add((sx, sy))
            return


def main():
    grid = Galaxies(5)
    grid.set_center(4, 1)
    grid.set_center(3, 3)
    grid.set_center(8, 4)
    grid.set_center(3, 5)
    grid.set_center(1, 8)
    grid.set_center(5, 8)
    grid.set_center(9, 8)
    grid.set_center(3, 9)

    # grid = Galaxies(7)
    # grid.set_center(8, 1)
    # grid.set_center(3, 2)
    # grid.set_center(12, 2)
    # grid.set_center(9, 4)
    # grid.set_center(2, 5)
    # grid.set_center(2, 8)
    # grid.set_center(6, 9)
    # grid.set_center(13, 9)
    # grid.set_center(10, 10)
    # grid.set_center(2, 13)
    # grid.set_center(10, 13)


    print('Input')
    print(grid)
    print('Running...')
    grid.run(interactive=True)


if __name__ == '__main__':
    main()
