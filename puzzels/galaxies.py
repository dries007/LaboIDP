#!/bin/env python3

"""
Galaxies (logic puzzle)

Rules:

1) Every region should have two-way rotational symmetry,
2) should contain exactly one dot which is in its centre, and
3) should contain no lines separating two of its own squares from each other.
4) No black holes.

Copyright © 2019 Dries Kennes <http://dries007.net> & Laurens VDW
All rights reserved.
"""
import itertools
import re
import string
import subprocess as sp
import textwrap
import time
from pprint import pprint

# Characters used for center (lower case is used for showing affiliation)
ALPHABET = string.ascii_uppercase + string.digits + string.punctuation

TEMPLATE = string.Template('''/* IDP file generated by Python script...
 *
${header}
 * 
 * Play field:
${field}
 */
// Vocabulary Block
vocabulary V {
    Size: nat
    type X isa nat
    type Y isa nat
    Center(X, Y)
    Walls(X, Y)
    Square(X, Y)
    Touching(X, Y, X, Y) // Square -> center
    BelongsTo(X, Y, X, Y) // Square -> center
    Reachable(X, Y, X, Y) // Square -> center 
}
// Structure Block
structure S : V {
    X = {0..${size}}
    Y = {0..${size}}
    Size = ${size}
    Center = { ${centers} }
}
// Theory Block
theory T : V {
    // Define a list of all "squares". (odd coordinates)
    { !x, y: Square(x, y) <- x%2=1 & y%2=1. }
    
    // Wall definitions
    // ----------------
    // Walls cannot be in square spots.
    !(x, y) in Walls: ~Square(x, y).
    // Walls cannot pass trough a center.
    !(x, y) in Walls: ~Center(x, y).
    // Every edge is a wall.
    !x: Walls(x, 0) & Walls(x, Size).
    !y: Walls(0, y) & Walls(Size, y).
    // A wall cannot be a dead end. It would subdivided a region. This translates too:
    // Every wall must have 2 or more neighbours.   X are equal, Y are +-1    OR Y are equal, X are +- 1.
    !(x1, y1) in Walls: #{x2[X], y2[Y]: Walls(x2, y2) & ((x1=x2 & (y1=y2-1|y1=y2+1)) | (y1=y2 & (x1=x2-1|x1=x2+1)))} >= 2.
    // Walls MUST surround regions on all sides.
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1-2, y1, cx1, cy1) <=> Walls(x1-1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1+2, y1, cx1, cy1) <=> Walls(x1+1, y1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1-2, cx1, cy1) <=> Walls(x1, y1-1)).
    !(x1, y1) in Square: !(cx1, cy1) in Center: BelongsTo(x1, y1, cx1, cy1) => (~BelongsTo(x1, y1+2, cx1, cy1) <=> Walls(x1, y1+1)).
    
    // Basic BelongsTo definitions
    // ---------------------------
    // If its not a square, it cant belong to anything.
    !x1, y1: ~Square(x1, y1) => #{x2[X], y2[Y]: BelongsTo(x1, y1, x2, y2)} = 0.
    // No polygamy here.
    !(x1, y1) in Square: #{x2[X], y2[Y]: BelongsTo(x1, y1, x2, y2)} = 1.
    // The belong-to part must be a center.
    !(x1, y1) in Square: ?(x2, y2) in Center: BelongsTo(x1, y1, x2, y2).
    
    // Touching relation
    {
        // Case 1: Center is on a cross
        !x, y: Touching(x-1, y-1, x, y) <- (x%2=0 & y%2=0) & Center(x, y).
        !x, y: Touching(x-1, y+1, x, y) <- (x%2=0 & y%2=0) & Center(x, y).
        !x, y: Touching(x+1, y+1, x, y) <- (x%2=0 & y%2=0) & Center(x, y).
        !x, y: Touching(x+1, y-1, x, y) <- (x%2=0 & y%2=0) & Center(x, y).
        // Case 2: Center is on a wall in X
        !x, y: Touching(x+1, y, x, y) <- (x%2=0 & y%2=1) & Center(x, y).
        !x, y: Touching(x-1, y, x, y) <- (x%2=0 & y%2=1) & Center(x, y).
        // Case 3: Center is on a wall in Y
        !x, y: Touching(x, y+1, x, y) <- (x%2=1 & y%2=0) & Center(x, y).
        !x, y: Touching(x, y-1, x, y) <- (x%2=1 & y%2=0) & Center(x, y).
        // Case 4: Center is in a square
        !x, y: Touching(x, y, x, y) <- Square(x, y) & Center(x, y).
    }
    // If a square is touching a center, it belongs to that center.
    !x, y, cx, cy: Touching(x, y, cx, cy) => BelongsTo(x, y, cx, cy).
    
    // Check region symmetry: mirror is 2 times center minus coordinate
    !(x, y) in Square: !(cx, cy) in Center: BelongsTo(x, y, cx, cy) <=> BelongsTo(2*cx-x, 2*cy-y, cx, cy).
    
    // Reachability relation (Region continuity)
    {
        // Touching squares are reachable. (This 'seeds' the recursive definition)
        !x, y, cx, cy: Reachable(x, y, cx, cy) <- Touching(x, y, cx, cy).
        // A square is reachable if there is no wall in between
        !x, y, cx, cy: Reachable(x-2, y, cx, cy) <- Square(x-2, y) & Reachable(x, y, cx, cy) & ~Walls(x-1, y).
        !x, y, cx, cy: Reachable(x+2, y, cx, cy) <- Square(x+2, y) & Reachable(x, y, cx, cy) & ~Walls(x+1, y).
        !x, y, cx, cy: Reachable(x, y-2, cx, cy) <- Square(x, y-2) & Reachable(x, y, cx, cy) & ~Walls(x, y-1).
        !x, y, cx, cy: Reachable(x, y+2, cx, cy) <- Square(x, y+2) & Reachable(x, y, cx, cy) & ~Walls(x, y+1).
    }
    // A square can only belong to a center if it's reachable.
    !(x, y) in Square: !(cx, cy) in Center: BelongsTo(x, y, cx, cy) <=> Reachable(x, y, cx, cy).
}
// Default main
procedure main() {
    stdoptions.nbmodels = 5
    printmodels(modelexpand(T,S))
}''')


def up(x, y, offset=1):
    return x, y-offset


def down(x, y, offset=1):
    return x, y+offset


def left(x, y, offset=1):
    return x-offset, y


def right(x, y, offset=1):
    return x+offset, y


DIRECTIONS = (up, down, left, right)


def is_square(x, y):
    return x % 2 == 1 and y % 2 == 1


def all_touching_squares(x, y):
    if x % 2 == 0 and y % 2 == 0:
        return {left(*up(x, y)), left(*down(x, y)), right(*up(x, y)), right(*down(x, y))}
    if x % 2 == 0:
        return {left(x, y), right(x, y)}
    if y % 2 == 0:
        return {up(x, y), down(x, y)}
    return {(x, y)}


def get_neighbours(x, y, size):
    if not is_square(x, y):
        raise ValueError('Not Square')
    neighbours = set()
    if x != 1:
        neighbours.add(left(x, y, offset=2))
    if x != size-2:
        neighbours.add(right(x, y, offset=2))
    if y != 1:
        neighbours.add(up(x, y, offset=2))
    if y != size-2:
        neighbours.add(down(x, y, offset=2))
    return neighbours


def between(a, b):
    ax, ay = a
    bx, by = b
    assert (ax+bx)//2 == (ax+bx)/2, (ay+by)//2 == (ay+by)/2
    return (ax+bx)//2, (ay+by)//2


def is_continuous(squares, size):
    if len(squares) == 0:
        return True
    explored = set()
    to_explore = {next(iter(squares))}
    while len(to_explore) > 0:
        pos = to_explore.pop()
        explored.add(pos)
        for n in get_neighbours(*pos, size):
            if n not in explored and n in squares:
                to_explore.add(n)
    return len(set(squares) ^ explored) == 0


def mirror(square, center):
    sx, sy = square
    cx, cy = center
    dx, dy = cx - sx, cy - sy
    return cx + dx, cy + dy


class Galaxies:
    def __init__(self, size, centers=None):
        self.centers = {}
        self.squares = set()
        self.mapping_s2c = {}
        self.mapping_c2s = {}
        self.size = 2 * size + 1

        self.nb_models = 5
        edges = {0, self.size-1}
        self.edge_walls = {(x, y) for x, y in itertools.product(range(self.size), range(self.size)) if x in edges or y in edges}
        self.walls = set(self.edge_walls)

        if centers:
            for x, y in centers:
                self.set_center(x, y)

    def __repr__(self):
        return self.get_grid()

    def get_grid(self):
        return '  ' + ''.join(str(x // 10) if x >= 10 else ' ' for x in range(self.size)) + '\n' + \
               '  ' + ''.join(str(x % 10) for x in range(self.size)) + '\n' + \
               '\n'.join('%2d' % y + ''.join(self.get_inner_tile(x, y) for x in range(self.size)) for y in range(self.size))

    def set_center(self, x, y):
        self.centers[x, y] = ALPHABET[len(self.centers)]

    def check_valid(self):
        """
        Must return True if the puzzle is solved correctly.
        """
        # Helper objects
        all_coords = tuple(itertools.product(range(self.size), range(self.size)))
        squares = set((x, y) for x, y in all_coords if is_square(x, y))
        non_squares = set((x, y) for x, y in all_coords if not is_square(x, y))

        # Conditions
        # Implemented in IDP already.
        all_walls_connected = all(sum(f(x, y) in self.walls for f in DIRECTIONS) >= 2 for x, y in self.walls)
        no_walls_in_boxes = not any(x % 2 and y % 2 for x, y in self.walls)
        every_square_has_value = all((x, y) in self.mapping_s2c for x, y in squares)
        only_squares_have_values = not any((x, y) in self.mapping_s2c for x, y in non_squares)
        # Polygamy (more than 1 value per square) is impossible because it's a dict.
        only_mappings_to_centers = len(set(self.mapping_c2s.keys()) - set(self.centers.keys())) == 0
        center_touching_squares = all(len(all_touching_squares(x, y) - self.mapping_c2s[x, y]) == 0 for x, y in self.centers.keys())
        different_walls = all((between(n, c) in self.walls for n in get_neighbours(*c, self.size) if self.mapping_c2s[n] != self.mapping_c2s[c]) for c in squares)
        same_no_walls = all((between(n, c) not in self.walls for n in get_neighbours(*c, self.size) if self.mapping_c2s[n] == self.mapping_c2s[c]) for c in squares)
        symmetric = all(mirror(s, c) in squares and self.mapping_s2c[mirror(s, c)] == c for s, c in self.mapping_s2c.items())
        continuous = all(is_continuous(region, self.size) for c, region in self.mapping_c2s.items())

        # Assert anything to make sure there is no unnoticed regression.
        assert all_walls_connected
        assert no_walls_in_boxes
        assert every_square_has_value
        assert only_squares_have_values
        assert only_mappings_to_centers
        assert center_touching_squares
        assert different_walls
        assert same_no_walls
        assert symmetric
        assert continuous

        return True

    def get_inner_tile(self, x, y):
        """
        Unicode Box Drawing Character Madness
        """
        pos = (x, y)
        if pos in self.centers:
            # return '╳'  # '◯'
            return self.centers[pos]

        wall = pos in self.walls
        wall_up = up(x, y) in self.walls
        wall_down = down(x, y) in self.walls
        wall_left = left(x, y) in self.walls
        wall_right = right(x, y) in self.walls

        x_even = x % 2 == 0
        y_even = y % 2 == 0

        end = self.size - 1
        edges = {0, end}

        # Special cas for edges, so that the printed version looks better.
        # Literally the corer and edge cases...
        if wall and x in edges or y in edges:
            if y == 0:
                if x == 0:
                    return '┏'
                if x == end:
                    return '┓'
                if not x_even:
                    return '━'
                return '┳' if wall_down else '┯'
            if y == end:
                if x == 0:
                    return '┗'
                if x == end:
                    return '┛'
                if not x_even:
                    return '━'
                return '┻' if wall_up else '┷'
            if x == 0:
                if not y_even:
                    return '┃'
                return '┣' if wall_right else '┠'
            if x == end:
                if not y_even:
                    return '┃'
                return '┫' if wall_left else '┨'

        if x_even and y_even:
            # Crossing
            if not wall:
                return '┼'

            # 4 legs are walls
            if all((wall_up, wall_down, wall_left, wall_right)):
                return '╋'

            # 1 leg is a wall. Should not happen.
            if wall_up and not any((wall_down, wall_left, wall_right)):
                return '╀'
            if wall_down and not any((wall_up, wall_left, wall_right)):
                return '╁'
            if wall_left and not any((wall_up, wall_down, wall_right)):
                return '┽'
            if wall_right and not any((wall_up, wall_down, wall_left)):
                return '┾'

            # 3 legs are walls.
            if not wall_up and all((wall_down, wall_left, wall_right)):
                return '╈'
            if not wall_down and all((wall_up, wall_left, wall_right)):
                return '╇'
            if not wall_left and all((wall_up, wall_down, wall_right)):
                return '╊'
            if not wall_right and all((wall_up, wall_down, wall_left)):
                return '╉'

            # 2 legs are a wall.
            if all((wall_up, wall_down)) and not any((wall_left, wall_right)):
                return '╂'
            if all((wall_left, wall_right)) and not any((wall_up, wall_down)):
                return '┿'
            if all((wall_up, wall_left)) and not any((wall_down, wall_right)):
                return '╃'
            if all((wall_up, wall_right)) and not any((wall_down, wall_left)):
                return '╄'
            if all((wall_down, wall_left)) and not any((wall_up, wall_right)):
                return '╅'
            if all((wall_down, wall_right)) and not any((wall_up, wall_left)):
                return '╆'

            raise ValueError('impossible')

        if y_even:
            return ('┄' if PRINT_INNER_WALLS else ' ') if not wall else '━'
        if x_even:
            return ('┆' if PRINT_INNER_WALLS else ' ') if not wall else '┃'

        if pos not in self.mapping_s2c:
            return ' '
        center = self.mapping_s2c[pos]
        if PRINT_AFFILIATION:
            return self.centers[center].lower()
        return ' '

    def to_idp(self):
        return TEMPLATE.substitute(
            header=textwrap.indent(__doc__.strip(), ' * ', lambda x: True),
            field=textwrap.indent(self.get_grid(), ' * ', lambda x: True),
            size=self.size - 1,
            centers='; '.join(repr(x) for x in self.centers),
            nbmodels=self.nb_models,
        )

    def run(self, interactive=False):
        idp = self.to_idp()

        with open('galaxies.idp', 'w') as f:
            print(idp, file=f)

        print('Input', self, 'Running...', sep='\n')

        start = time.perf_counter()
        p = sp.Popen(('idp', ), universal_newlines=True, stdin=sp.PIPE, stdout=sp.PIPE,  stderr=sp.STDOUT)
        stdout, stderr = p.communicate(idp)
        print('Runtime: ', time.perf_counter() - start)

        with open('galaxies.idp', 'w') as f:
            print(idp, file=f)
            print('/* IDP Output', file=f)
            print(20 * '-=#=-', file=f)
            print(stdout, file=f)
            print(20*'-=#=-', file=f)
            for line in stdout.splitlines():
                self.parse_input(line, file=f)
            print('*/', file=f)

        if interactive:
            while True:
                self.parse_input(input('IDP Output > '))

    def parse_input(self, inp, file=None):
        if len(inp.strip()) == 0:
            # print('Solution:', file=file)
            # print('Centers:', self.centers, file=file)
            # print('Inner Walls:', self.walls - self.edge_walls, file=file)
            # print('Mapping Center -> Square:', file=file)
            # pprint(self.mapping_c2s, stream=file, width=160)
            # print('Mapping Square -> Center:', file=file)
            # pprint(self.mapping_s2c, stream=file, width=160)
            print('Grid:', file=file)
            print(self, file=file)
            print(file=file)
            if file:
                print(self)
                print('Valid:', self.check_valid())
            print('Valid:', self.check_valid(), file=file)
            return

        match = re.match(r'^\s*Walls = {(.*)}$', inp)
        if match:
            self.walls = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            return
        match = re.match(r'^\s*Center = {(.*)}$', inp)
        if match:
            centers = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            assert len(set(self.centers.keys()) ^ centers) == 0
            return
        match = re.match(r'^\s*Square = {(.*)}$', inp)
        if match:
            self.squares = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            return
        match = re.match(r'^\s*Size = (\d+)$', inp)
        if match:
            assert int(match.group(1)) == self.size-1
            return
        match = re.match(r'^\s*BelongsTo = {(.*)}$', inp)
        if match:
            mapping = {tuple(map(int, x.split(','))) for x in match.group(1).split(';')}
            self.mapping_s2c = {(sx, sy): (cx, cy) for sx, sy, cx, cy in mapping}
            self.mapping_c2s = {(cx, cy): set() for cx, cy in self.mapping_s2c.values()}
            for sx, sy, cx, cy in mapping:
                self.mapping_c2s[cx, cy].add((sx, sy))
            return


# Some settings
PRINT_AFFILIATION = False
PRINT_INNER_WALLS = False


def main():
    grid5.run(interactive=False)
    grid7.run(interactive=False)
    grid10.run(interactive=False)
    grid15.run(interactive=True)


# All from https://www.chiark.greenend.org.uk/~sgtatham/puzzles/js/galaxies.html
grid5 = Galaxies(5, centers=((4, 1), (3, 3), (8, 4), (3, 5), (1, 8), (5, 8), (9, 8), (3, 9)))

# 7x7
grid7 = Galaxies(7, centers=((8, 1), (3, 2), (12, 2), (9, 4), (2, 5), (2, 8), (6, 9), (13, 9), (10, 10), (2, 13), (10, 13)))

# 10x10dn seed: 707927189213725
grid10 = Galaxies(10, centers=((2, 1), (7, 1), (13, 1), (19, 2), (5, 3), (11, 4), (14, 4), (6, 5), (17, 5), (1, 7), (5, 8), (12, 8), (19, 8), (1, 10), (3, 11), (13, 11), (17, 11), (5, 12), (7, 13), (14, 13), (2, 14), (10, 14), (6, 15), (18, 16), (13, 17), (2, 18), (7, 18), (5, 19), (15, 19)))

# 15x15dn seed: 968010066204914
grid15 = Galaxies(15, centers=((3, 1), (9, 1), (20, 1), (6, 2), (11, 2), (14, 3), (18, 3), (25, 3), (6, 5), (5, 7), (22, 8), (1, 9), (13, 9), (4, 10), (23, 11), (7, 12), (29, 12), (1, 13), (15, 13), (9, 14), (12, 14), (21, 14), (28, 16), (15, 17), (25, 17), (4, 18), (19, 18), (13, 19), (1, 20), (22, 20), (27, 21), (12, 22), (17, 22), (21, 24), (5, 25), (19, 25), (29, 25), (1, 26), (9, 26), (12, 26), (15, 26), (26, 26), (6, 27), (22, 27), (22, 27), (5, 29), (14, 29), (23, 29), (27, 29)))

if __name__ == '__main__':
    main()

